#include <stdlib.h>
#include <stdio.h>
#include <queue>
using namespace std;
typedef struct Node
{
	int elem;
	int depth;
	Node* root;
}Node;

typedef struct Input	// 루트노드에 연결되지 않은 경우 입력값을 저장할 구조
{
	int n1, n2;
}Input;

int main()
{
	queue <Input *> q;
	int numCases, n1, n2;
	scanf_s("%d", &numCases);
	Node ** arr = new Node * [numCases + 1];	// node의 주소를 갖는 리스트
	for (int i = 1; i < numCases + 1; i++)
	{
		arr[i] = NULL;
	}
	Node* rootNode = new Node;	// 루트 노드인 1번 노드 초기화
	rootNode->elem = 1;
	rootNode->depth = 1;
	rootNode->root = NULL;
	arr[1] = rootNode;
	for (int i = 1; i < numCases; i++)	
	{
		scanf_s("%d %d", &n1, &n2);
		if (arr[n1] == NULL && arr[n2] != NULL)			// case1. n2는 이미 루트노드에 붙어 있는 경우
		{
			Node* tmpNode = new Node;
			tmpNode->elem = n1;
			tmpNode->depth = arr[n2]->depth + 1;
			tmpNode->root = arr[n2];
			arr[n1] = tmpNode;
		}
		else if (arr[n2] == NULL && arr[n1] != NULL)	// case2. n1는 이미 루트노드에 붙어 있는 경우
		{
			Node* tmpNode = new Node;
			tmpNode->elem = n2;
			tmpNode->depth = arr[n1]->depth + 1;
			tmpNode->root = arr[n1];
			arr[n2] = tmpNode;
		}	
		else											// case 3. n1, n2 아직 루트 노드에 붙어 있지 않으면 입력값을 큐에 저장
		{
			Input* inp = new Input;
			inp->n1 = n1;
			inp->n2 = n2;
			q.push(inp);
		}
	}
	while (!q.empty())									// case 3를 처리하기 위해 큐가 빌 때까지 큐의 앞 부분을 다시 입력하고 pop을 반복
	{
		n1 = q.front()->n1;
		n2 = q.front()->n2;
		q.pop();
		Node* tmpNode = new Node;	
		if (arr[n1] == NULL && arr[n2] != NULL)
		{
			tmpNode->elem = n1;
			tmpNode->depth = arr[n2]->depth + 1;
			tmpNode->root = arr[n2];
			arr[n1] = tmpNode;
		}
		else if (arr[n2] == NULL && arr[n1] != NULL)
		{
			tmpNode->elem = n2;
			tmpNode->depth = arr[n1]->depth + 1;
			tmpNode->root = arr[n1];
			arr[n2] = tmpNode;
		}
		else
		{
			Input* inp = new Input;
			inp->n1 = n1;
			inp->n2 = n2;
			q.push(inp);
		}
	}
	scanf_s("%d", &numCases);
	for (int i = 0; i < numCases ; i++)						// LCA의 핵심-> 같은 depth가 될 때까지 더 아래에 있는 노드를 부모 노드로 올린 후 비교
	{
		scanf_s("%d %d", &n1, &n2);
		while (arr[n1]->depth != arr[n2]->depth)
		{
			if (arr[n1]->depth > arr[n2]->depth)
			{
				n1 = arr[n1]->root->elem;
			}
			else
			{
				n2 = arr[n2]->root->elem;
			}
		}
		while (n1 != n2)
		{
			n1 = arr[n1]->root->elem;
			n2 = arr[n2]->root->elem;
		}
		printf("%d\n", n1);
	}
}
